{
  "version": "1.9.0", 
  "nickname": "LoadMapper", 
  "outputs": [
    [
      {
        "access": "None", 
        "name": "mapper", 
        "description": "A mapper measure object can be plugged into the \"measures_\" input\nof the \"DF Run URBANopt\" component in order to be included in the\nsimulation.", 
        "type": null, 
        "default": null
      }
    ]
  ], 
  "inputs": [
    {
      "access": "item", 
      "name": "_measure_path", 
      "description": "Path to the folder in which the measure exists. This folder\nmust contain a measure.rb and a measure.xml file. Note that connecting\nan input here will transform the component, essentially removing this\ninput and changing all of the other component inputs to be input\narguments for the measure.", 
      "type": "string", 
      "default": null
    }
  ], 
  "subcategory": "3 :: Energy", 
  "code": "\ntry:\n    from dragonfly_energy.measure import MapperMeasure\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import dragonfly_energy:\\n\\t{}'.format(e))\n\ntry:  # import the ladybug_{{cad}} dependencies\n    from ladybug_{{cad}}.{{plugin}} import all_required_inputs, give_warning, \\\n        turn_off_old_tag\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_{{cad}}:\\n\\t{}'.format(e))\nturn_off_old_tag(ghenv.Component)\n\nimport {{Plugin}}.Kernel as gh\n\n\ndef add_component_input_from_arg(argument):\n    \"\"\"Add an input parameter to this component using a MapperMeasureArgument object.\n\n    Args:\n        argument: A dragonfly-energy MapperMeasureArgument object that will be used\n            to create a new input parameter for the component.\n    \"\"\"\n    # create the input parameter object\n    param = gh.Parameters.Param_ScriptVariable()\n\n    # assign the required properties to the input\n    arg_id = '_{}'.format(argument.identifier) if argument.required else \\\n        '{}_'.format(argument.identifier)\n    param.NickName = arg_id\n    param.Name = arg_id if argument.display_name is None else argument.display_name\n    param.AllowTreeAccess = False\n    param.Access = gh.{{PLGN}}_ParamAccess.list  # MapperMeasures mist be lists\n    param.Optional = True  # always needed so that default can come from measure file\n\n    # assign the optional properties to the input if they exist\n    if argument.type_text == 'Choice':\n        descr = [argument.description] if argument.description else []\n        if None not in argument.valid_choices:\n            descr.append('Choose from the following options:')\n            descr = descr + list(argument.valid_choices)\n        param.Description = '\\n '.join(descr)\n    elif argument.description:\n        param.Description = argument.description\n    if argument.default_value is not None:\n        param.AddVolatileData(gh.Data.{{PLGN}}_Path(0), 0, argument.default_value)\n    elif argument.type_text == 'Choice' and argument.valid_choices == (None,):\n        param.AddVolatileData(gh.Data.{{PLGN}}_Path(0), 0, 'None')\n\n    # add the parameter to the compoent\n    index = ghenv.Component.Params.Input.Count\n    ghenv.Component.Params.RegisterInputParam(param, index)\n    ghenv.Component.Params.OnParametersChanged()\n\ndef transform_name_and_description(measure):\n    \"\"\"Transform this component's name and description to match a measure.\n\n    Args:\n        measure: A dragonfly-energy MapperMeasure object that will be used to assign\n            this component's name and description.\n    \"\"\"\n    # assign the measure metadata\n    ghenv.Component.NickName = measure.identifier\n    ghenv.Component.Name = measure.display_name if measure.display_name \\\n        else measure.identifier\n    if measure.description:\n        ghenv.Component.Description = measure.description\n\n\ndef transform_component(measure):\n    \"\"\"Transform this component to have a name and arguments that match a measure.\n\n    Args:\n        measure: A dragonfly-energy MapperMeasure object that will be used to assign\n            this component's name, description, and input arguments.\n    \"\"\"\n    # assign the measure metadata\n    transform_name_and_description(measure)\n    # assign the input arguments\n    for arg in measure.arguments:\n        add_component_input_from_arg(arg)\n\n\ndef check_arguments_and_set_defaults(measure):\n    \"\"\"Check to be sure the names of component inputs align with measure arguments.\n\n    This method will also assign any default values from the measure if there is\n    no value input to the component.\n\n    Args:\n        measure: A dragonfly-energy MapperMeasure object that will be used check this\n            component's input arguments.\n    \"\"\"\n    for i in range(1, ghenv.Component.Params.Input.Count):\n        # get the param and the measure argument object\n        param = ghenv.Component.Params.Input[i]\n        arg = measure_init.arguments[i - 1]\n\n        # check that the param matches the measure argument\n        assert arg.identifier in param.NickName, \\\n            \"This component's inputs do not match that of the input measure.\\n\" \\\n            \"Grab a fresh 'HB Load MapperMeasure' component and reload the measure.\"\n\n        # add any default values\n        if not param.VolatileDataCount or param.VolatileData[0][0] is None:\n            if arg.default_value is not None:\n                param.AddVolatileData(gh.Data.{{PLGN}}_Path(0), 0, arg.default_value)\n            elif arg.type_text == 'Choice' and arg.valid_choices == (None,):\n                param.AddVolatileData(gh.Data.{{PLGN}}_Path(0), 0, 'None')\n\n\ndef update_measure_arguments(measure):\n    \"\"\"Update the arguments of a measure object based on this component's inputs.\n\n    Args:\n        measure: A dragonfly-energy MapperMeasure object to have its arguments updated\n            with the inputs to this component.\n    \"\"\"\n    for i in range(1, ghenv.Component.Params.Input.Count):\n        try:\n            value = list(ghenv.Component.Params.Input[i].VolatileData[0])\n            print value\n            if value != [None]:\n                # cast to string to avoid weird {{Plugin}} types\n                val = [str(v) for v in value]\n                argument = measure.arguments[i - 1]\n                if argument.valid_choices == (None,) and val == ['None']:\n                    pass  # choice argument with no valid choices\n                else:\n                    argument.value = val if val != ['False'] else [False]\n        except Exception:  # there is no input for this value; just ignore it\n            pass\n\n\ndef is_measure_input():\n    \"\"\"Check if a measure path is input to this component.\n\n    This is needed because we don't know if there are default values for all\n    required inputs until we load the measure.\n    \"\"\"\n    if _measure_path is None:\n        msg = 'Input parameter _measure_path failed to collect data!'\n        print(msg)\n        give_warning(ghenv.Component, msg)\n        return False\n    return True\n\n\nif is_measure_input():\n    # load the measure\n    measure_init = MapperMeasure(_measure_path)\n\n    # transform the component or check the inputs and set defaults\n    if ghenv.Component.Params.Input.Count == 1:  # first time loading the measure\n        transform_component(measure_init)\n    else:  # the component has already been transformed\n        transform_name_and_description(measure_init)\n        check_arguments_and_set_defaults(measure_init)\n\n    # if the measure has all inputs that it needs, output the measure\n    if all_required_inputs(ghenv.Component):\n        update_measure_arguments(measure_init)\n        mapper = measure_init\n", 
  "category": "Dragonfly", 
  "name": "DF Load Mapper Measure", 
  "description": "Load OpenStudio measures into Grasshopper and assign the measure's input arguments\nin a manner that can be mapped to different buildings in a Dragonfly model.\n_\nThe resulting measure object can be plugged into the \"measures_\" input of the\n\"DF Run URBANopt\" component in order to be included in the simulation.\n-"
}